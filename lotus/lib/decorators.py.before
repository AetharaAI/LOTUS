"""
Decorators for LOTUS Modules

Provides decorators for:
- Event handling (@on_event)
- Tool registration (@tool)
- Periodic tasks (@periodic)
"""

from functools import wraps
from typing import Callable, Any


def on_event(event_name: str) -> Callable:
    """
    Decorator to mark a method as an event handler
    
    The decorated method will be called whenever the specified event is published.
    
    Args:
        event_name: The event channel to listen to (e.g., "cognition.task_request")
    
    Example:
        @on_event("perception.screen_update")
        async def handle_screen_update(self, event):
            screen_data = event.data
            await self.analyze_screen(screen_data)
    
    The handler receives an Event object with:
        - name: Event name
        - data: Event data
        - source: Module that published the event
        - timestamp: When the event was published
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs):
            return await func(*args, **kwargs)
        
        # Mark the function with metadata for registration
        wrapper._event_name = event_name
        return wrapper
    
    return decorator


def tool(name: str = None, description: str = None) -> Callable:
    """
    Decorator to mark a method as a callable tool
    
    Tools can be called by other modules or by the reasoning engine.
    
    Args:
        name: Optional tool name (defaults to function name)
        description: Optional tool description for LLM context
    
    Example:
        @tool("analyze_code")
        async def analyze_code(self, code: str, language: str = "python") -> dict:
            \"\"\"Analyze code for bugs and suggestions\"\"\"
            # Perform analysis
            return {
                "bugs": [],
                "suggestions": []
            }
    
    Tools should:
    - Have type hints for parameters
    - Return JSON-serializable data
    - Have docstrings (used for LLM context)
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs):
            return await func(*args, **kwargs)
        
        # Mark the function with metadata
        wrapper._tool_name = name or func.__name__
        wrapper._tool_description = description or func.__doc__
        return wrapper
    
    return decorator


def periodic(interval: int) -> Callable:
    """
    Decorator to mark a method to run periodically
    
    The decorated method will be called every `interval` seconds.
    
    Args:
        interval: Seconds between executions
    
    Example:
        @periodic(interval=60)
        async def save_state(self):
            \"\"\"Save module state every 60 seconds\"\"\"
            await self.persist_state()
        
        @periodic(interval=5)
        async def check_for_updates(self):
            \"\"\"Check for updates every 5 seconds\"\"\"
            updates = await self.fetch_updates()
            if updates:
                await self.process_updates(updates)
    
    The task runs in the background and will be cancelled during module shutdown.
    Exceptions in periodic tasks are logged but don't crash the module.
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs):
            return await func(*args, **kwargs)
        
        # Mark the function with metadata
        wrapper._periodic_interval = interval
        return wrapper
    
    return decorator


def rate_limit(calls: int, period: int) -> Callable:
    """
    Decorator to rate-limit a method
    
    Limits how often a method can be called.
    
    Args:
        calls: Number of calls allowed
        period: Time period in seconds
    
    Example:
        @rate_limit(calls=10, period=60)
        async def expensive_operation(self):
            # This can only be called 10 times per minute
            pass
    """
    from collections import deque
    from time import time
    
    def decorator(func: Callable) -> Callable:
        calls_times = deque(maxlen=calls)
        
        @wraps(func)
        async def wrapper(*args, **kwargs):
            now = time()
            
            # Remove calls older than period
            while calls_times and calls_times[0] < now - period:
                calls_times.popleft()
            
            # Check if we've hit the limit
            if len(calls_times) >= calls:
                wait_time = period - (now - calls_times[0])
                raise Exception(f"Rate limit exceeded. Try again in {wait_time:.1f}s")
            
            # Record this call
            calls_times.append(now)
            
            # Execute function
            return await func(*args, **kwargs)
        
        return wrapper
    
    return decorator


def retry(max_attempts: int = 3, delay: float = 1.0, backoff: float = 2.0) -> Callable:
    """
    Decorator to retry a method on failure
    
    Args:
        max_attempts: Maximum number of attempts
        delay: Initial delay between retries (seconds)
        backoff: Multiplier for delay after each retry
    
    Example:
        @retry(max_attempts=3, delay=1.0, backoff=2.0)
        async def fetch_data(self):
            # This will retry up to 3 times with exponential backoff
            return await self.api.get("/data")
    """
    import asyncio
    
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_delay = delay
            last_exception = None
            
            for attempt in range(max_attempts):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    if attempt < max_attempts - 1:
                        await asyncio.sleep(current_delay)
                        current_delay *= backoff
            
            # All retries failed
            raise last_exception
        
        return wrapper
    
    return decorator


def cache(ttl: int = 60) -> Callable:
    """
    Decorator to cache method results
    
    Args:
        ttl: Time-to-live in seconds
    
    Example:
        @cache(ttl=300)
        async def expensive_computation(self, param: str):
            # Result will be cached for 5 minutes
            return await self.compute(param)
    """
    from time import time
    
    def decorator(func: Callable) -> Callable:
        cache_store = {}
        
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Create cache key from args/kwargs
            key = (args, tuple(sorted(kwargs.items())))
            
            # Check cache
            if key in cache_store:
                result, timestamp = cache_store[key]
                if time() - timestamp < ttl:
                    return result
            
            # Compute result
            result = await func(*args, **kwargs)
            
            # Store in cache
            cache_store[key] = (result, time())
            
            return result
        
        return wrapper
    
    return decorator