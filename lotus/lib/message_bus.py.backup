"""
Message Bus - Redis Pub/Sub Wrapper

Provides event-driven communication between modules using Redis.

Features:
- Publish/Subscribe messaging
- Redis Streams for event history
- JSON serialization
- Audit stream for persistent tracing (stream:debug.messages)
"""

import asyncio
import json
from typing import Callable, Any, Dict, List, Optional
from datetime import datetime
import redis.asyncio as redis


class MessageBus:
    """Redis-based message bus for inter-module communication."""

    def __init__(self, config=None, host: str = "localhost", port: int = 6379, db: int = 0):
        # Handle Config object
        if config is not None:
            if hasattr(config, 'get'):
                # It's a Config object
                self.host = config.get("redis.host", host)
                self.port = config.get("redis.port", port)
                self.db = config.get("redis.db", db)
            else:
                # It's a dict-like object
                self.host = config.get("redis.host", host) if hasattr(config, 'get') else host
                self.port = config.get("redis.port", port) if hasattr(config, 'get') else port
                self.db = config.get("redis.db", db) if hasattr(config, 'get') else db
        else:
            self.host = host
            self.port = port
            self.db = db

        self.redis: Optional[redis.Redis] = None
        self.pubsub: Optional[redis.client.PubSub] = None

        # Subscriptions: channel -> [callbacks]
        self.subscriptions: Dict[str, List[Callable]] = {}

        # Background task for handling messages
        self.message_task: Optional[asyncio.Task] = None

        self.connected = False

    async def connect(self) -> None:
        """Connect to Redis"""
        self.redis = redis.Redis(
            host=self.host,
            port=self.port,
            db=self.db,
            decode_responses=True
        )

        # Test connection
        await self.redis.ping()

        # Create pubsub instance
        self.pubsub = self.redis.pubsub()

        # Start message handler
        self.message_task = asyncio.create_task(self._message_handler())

        self.connected = True

    async def disconnect(self) -> None:
        """Disconnect from Redis"""
        self.connected = False

        # Cancel message handler
        if self.message_task:
            self.message_task.cancel()
            try:
                await self.message_task
            except asyncio.CancelledError:
                pass

        # Unsubscribe all subscriptions to clear callbacks and free references
        try:
            for channel, callbacks in list(self.subscriptions.items()):
                for cb in list(callbacks):
                    try:
                        await self.unsubscribe(channel, cb)
                    except Exception:
                        pass
            self.subscriptions.clear()
        except Exception:
            # best-effort cleanup
            pass

        # Close pubsub/connection
        if self.pubsub:
            await self.pubsub.close()

        if self.redis:
            await self.redis.close()

    def _get_stream_name(self, channel: str) -> str:
        """Get Redis stream name for a channel"""
        return f"stream:{channel}"

    async def publish(self, channel: str, data: Any) -> None:
        """Publish a message to a channel

        Args:
            channel: Channel name (e.g., "cognition.task_request")
            data: Message data (will be JSON serialized)

        The message is:
        1. Published to Redis Pub/Sub for real-time delivery
        2. Added to Redis Stream for history
        3. Appended to stream:debug.messages for audit
        """
        if not self.connected:
            raise Exception("Not connected to Redis")

        # Guard against extremely large perception vectors or payloads
        if isinstance(data, (list, dict)):
            try:
                size = len(data)
            except Exception:
                size = 0
            if size > 10000:
                raise ValueError("Perception data too large for bus")

        # Serialize data
        message = {
            "channel": channel,
            "data": data,
            "timestamp": datetime.utcnow().isoformat()
        }

        serialized = json.dumps(message)

        # Publish to Pub/Sub (debug log)
        try:
            print(f"[msgbus-publish] channel={channel} timestamp={message['timestamp']}")
        except Exception:
            pass
        await self.redis.publish(channel, serialized)

        # Add to stream for history
        stream_name = self._get_stream_name(channel)
        try:
            await self.redis.xadd(stream_name, {"data": serialized}, maxlen=10000)
        except Exception as e:
            # Log stream write failures to stdout to ensure capture even if logger is misconfigured
            print(f"[msgbus-xadd-fail] stream={stream_name} error={e}")

        # Audit entry (bounded length to avoid unbounded growth)
        try:
            await self.redis.xadd("stream:debug.messages", {"direction": "publish", "channel": channel, "data": json.dumps(data), "ts": datetime.utcnow().isoformat()}, maxlen=5000)
        except Exception:
            pass

    async def subscribe(self, channel: str, callback: Callable) -> None:
        """Subscribe to a channel"""
        if channel not in self.subscriptions:
            self.subscriptions[channel] = []

            # Subscribe in Redis
            if "*" in channel:
                await self.pubsub.psubscribe(channel)
            else:
                await self.pubsub.subscribe(channel)

        self.subscriptions[channel].append(callback)

    async def unsubscribe(self, channel: str, callback: Callable) -> None:
        """Unsubscribe from a channel"""
        if channel in self.subscriptions:
            if callback in self.subscriptions[channel]:
                self.subscriptions[channel].remove(callback)

            # If no more callbacks, unsubscribe from Redis
            if not self.subscriptions[channel]:
                if "*" in channel:
                    await self.pubsub.punsubscribe(channel)
                else:
                    await self.pubsub.unsubscribe(channel)
                del self.subscriptions[channel]

    async def _message_handler(self) -> None:
        """Background task that handles incoming messages"""
        while self.connected:
            try:
                # Only process messages if we have subscriptions
                if self.subscriptions:
                    message = await self.pubsub.get_message(ignore_subscribe_messages=True, timeout=1.0)

                    if message and message["type"] in ["message", "pmessage"]:
                        # Deserialize message
                        try:
                            data = json.loads(message["data"])
                            channel = data["channel"]
                            payload = data["data"]
                        except Exception:
                            # Fallback: raw payload
                            channel = message.get("channel") or message.get("pattern") or "unknown"
                            payload = message.get("data")

                        # Debug: print receipt of message for tracing
                        try:
                            print(f"[msgbus-recv] channel={channel} type={message.get('type')} payload_type={type(payload)}")
                        except Exception:
                            pass

                        # write audit entry asynchronously (bounded)
                        try:
                            loop = asyncio.get_event_loop()
                            loop.create_task(self.redis.xadd("stream:debug.messages", {"direction": "recv", "channel": channel or "unknown", "data": json.dumps(payload), "ts": datetime.utcnow().isoformat()}, maxlen=5000))
                        except Exception:
                            pass

                        # Dispatch to matching subscriptions and ensure we free payload refs
                        try:
                            for pattern, callbacks in self.subscriptions.items():
                                if self._channel_matches(channel, pattern):
                                    for callback in callbacks:
                                        try:
                                            await callback(channel, payload)
                                        except Exception as e:
                                            print(f"Error in message handler: {e}")
                        finally:
                            # free large payload references from this loop iteration
                            try:
                                del payload
                            except Exception:
                                pass
                            try:
                                import gc
                                gc.collect()
                            except Exception:
                                pass
                else:
                    # No subscriptions, just sleep
                    await asyncio.sleep(1.0)

                await asyncio.sleep(0.01)  # Small delay to prevent tight loop

            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"Message handler error: {e}")
                await asyncio.sleep(1)  # Back off on error

    def _channel_matches(self, channel: str, pattern: str) -> bool:
        """Check if channel matches pattern (supports wildcards)"""
        if "*" not in pattern:
            return channel == pattern

        # Simple wildcard matching
        parts = pattern.split("*")
        if len(parts) == 2:
            prefix, suffix = parts
            return channel.startswith(prefix) and channel.endswith(suffix)

        return False

    async def get_history(self, channel: str, count: int = 100, start: str = "-", end: str = "+") -> List[Dict]:
        """Get historical messages from a channel"""
        stream_name = self._get_stream_name(channel)
        messages = await self.redis.xrange(stream_name, start, end, count)

        result = []
        for msg_id, fields in messages:
            try:
                data = json.loads(fields["data"])
                result.append({
                    "id": msg_id,
                    "channel": data["channel"],
                    "data": data["data"],
                    "timestamp": data["timestamp"]
                })
            except Exception:
                result.append({"id": msg_id, "raw": fields})

        return result

    async def get_latest(self, channel: str, count: int = 1) -> Optional[Dict]:
        """Get the most recent message from a channel"""
        history = await self.get_history(channel, count=count, start="-", end="+")
        return history[-1] if history else None